# 3장 가비지 컬렉터와 메모리 할당 전략

가비지 컬렉션이 처리해야 하는 문제

- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 할까?
- 어떻게 회수해야 할까?

가비지 컬렉션 기술이 상당히 발전됐음에도 **가비지 컬렉션**과 **메모리 할당의 내부**를 이해해야 하는 이유가 뭘까?

- 다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황
- 더 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황

이 상황들이 왔을 때 가비지 컬렉션과 메모리 할당으로 인해 자동화된 영역을 적절히 모니터링하고 조율할 수 있어야 하기 때문이다.

## 대상이 죽었는가?

자바에서는 거의 모든 객체 인스턴스가 힙에 저장된다. 가비지 컬렉터가 힙을 청소하려면 가장 먼저 **어떤 객체가 살아 있고**, 또 **어떤 객체가 죽었는지** 판단해야 한다.

### 참조 카운팅 알고리즘

1. 객체를 가리키는 참조 카운터(reference counter)를 추가한다. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.
2. 참조하는 곳이 하나 사라질 때마다 카운터 값을 1씩 감소시킨다.
3. 카운터 값이 0이 된 객체는 더는 사용될 수 없다.

하지만 자바 가상 머신에서는 사용하지 않는다. 고려해야 할 상황도 발생하고, 순환 참조를 해결하기 어렵기 때문이다.

### 도달 가능성 분석 알고리즘

자바, C# 등 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능성 분석(reachability analysis) 알고리즘을 이용한다.

GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 사용한다. 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다. 탐색 과정에서 만들어지는 경로를 참조 체인(referecne chain)이라 한다. 그리고 어떤 객체와 GC 루트 사이를 이어 주는 참조 체인이 없다면, 즉 GC 루트로부터 도달 불가능한 객체는 회수 대상으로 판별한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/4d56b05f-862b-4edf-850e-f96f09d54994/image.png)

자바에서 GC 루트로 이용할 수 있는 객체의 대표적인 예

- 가상 머신 스택(스택 프레임의 지역 변수 테이블)에서 참조하는 객체 : 현재 실행 중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체 : 자바 클래스의 참조 타입 정적 변수
- 메서드 영역에서 상수로 참조되는 객체 : 문자열 테이블 안의 참조
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- 자바 가상 머신 내부에서 쓰이는 참조 : 기본 데이터 타입에 해당하는 Class 객체, (NPE, OOE 등의) 일부 상주 예외 객체, 시스템 클래스 로더
- 동기화 락(synchronized)으로 잠겨 있는 모든 객체
- 자바 가상 머신 내부 상황을 반영하는 JMXBean : JVMTI에 등록된 콜백, 로컬 코드 캐시 등

이외에도 가비지 컬렉터 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 **임시로** 추가될 수 있다.

### 다시 참조 이야기로

객체의 생사 판단과 **참조**는 떼어서 생각할 수 없다.

JDK 1.2부터 참조 개념이 확장되어 구분된 참조 네 가지

- 강한 참조(strong reference)
    - 가장 전통적인 정의의 참조를 말한다. `Object obj = new Object()` 처럼 프로그램 코드에서 참조를 할당하는 걸 말한다. 강한 참조 관계가 남아 있는 객체는 가비지 컬렉터가 절대 회수하지 않는다.
- 부드러운 참조(soft reference)
    - 유용하지만 필수는 아닌 객체를 표현한다. 부드러운 참조만 남은 객체라면 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 회수 목록에 추가된다. 두 번째 회수 후에도 메모리가 부족하면 그때 메모리 오버플로 예외를 던진다.
- 약한 참조(weak reference)
    - 부드러운 참조와 비슷하지만 연결 강도가 더 약하다. 약한 참조뿐인 객체는 다음번 가비지 컬렉션까지만 살아 있다. 가비지 컬렉터가 동작하기 시작하면 메모리가 넉넉하더라도 약하게 참조된 객체는 모두 회수된다.
- 유령 참조(phantom referecne)
    - 참조 중에 가장 약하다. 객체 수명에 아무런 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능하다. 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서다.

> **파이널 참조**
JDK 내부적으로는 **파이널 참조(final Reference)**라는 유형도 쓰인다. 참조 강도는 약한 참조와 유령 참조 사이다. `finalize()` 메서드를 구현한 객체는 모두 파이널 참조의 대상이 되어 별도의 대기열(queue)에 등록된다. 그런 다음 해당 객체에 도달할 수 있는 강한 참조, 부드러운 참조, 약한 참조가 모두 없어지면 `finalize()` 메서드를 호출한다.
> 

### 살았나 죽었나?

도달 가능성 분석 알고리즘이 **도달 불가능**으로 판단한 객체라고 해서 반드시 죽어야 하는건 아니다. 아직 **유예** 단계가 남았고, 확실한 사망 선고를 내리려면 두 번의 **표시(marking)** 과정을 거쳐야 한다.

도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 이어서 필터링이 진행된다.

- 필터링 조건은 종료자(finalizer), 즉 **finalize() 메서드를 실행해야 하는 객체인가**이다.
- **finalize()**가 필요 없는 객체이거나 가상 머신이 **finalize()**를 이미 호출한 경우 **모두 실행할 필요 없음**으로 처리한다.

**finalize()**를 실행해야 하는 객체로 판명되면 **F-큐 (F-Queue)**라는 대기열에 추가된다. 그러면 가상 머신이 나중에 우선순위가 낮은 종료자 스레드를 생성해 **F-큐**에 들어 있는 객체들의  **finalize()** 메서드를 실행한다.

> **finalize() 는 어떤 객체든 시스템이 한 번만 호출한다.**
> 

### 메서드 영역 회수하기

《자바 가상 머신 명세》에 따르면 가비지 컬렉터가 메서드 영역을 반드시 청소해야 하는 건 아니다. 실제로도 메서드 영역 타입 언로딩을 구현하지 않거나 완벽하게 수행하지 않는 가상 머신도 있다.

메서드 영역 가비지 컬렉션은 대체로 **비용 효율**이 좋지 않기 때문이다. 일반적인 애플리케이션에서 자바 힙은, 그중에서도 특히 신세대는 가비지 컬렉션 한 번으로 메모리 공간의 70~99%를 회수해 낸다. 반면 메서드 영역은 회수 조건이 까다로워서 효율이 훨씬 떨어진다.

메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다. 더 이상 사용되지 않는 **상수**와 **클래스**다.

- 상수
    - 자바 힙에서 객체를 회수하는 방법과 매우 비슷하다. 상수 풀 안의 `java` 상수를 참조하는 문자열 객체가 전혀 없고, 가상 머신에서 이 리터럴을 사용하는 코드가 한 곳도 없다. 이 시점에 회수가 시작되면 가비지 컬렉터는 `java` 상수를 상수 풀에서 치워 버려야 한다고 판단할 것이다. 상수 풀에 있는 다른 클래스(인터페이스 포함), 메서드, 필드의 심벌 참조도 비슷한 방법으로 회수한다.
- 클래스
    - 클래스는 상수보다 좀 더 회수 조건이 까다로우며, 다음 세 조건을 동시에 만족해야 한다.
        - 이 클래스의 인스턴스가 모두 회수되었다. 즉, 자바 힙에는 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
        - 이 클래스를 읽어 들인 클래스 로더가 회수되었다. 이 조건은 OSGI나 JSP 리로딩처럼 세심하게 설계된 대안 클래스 로더 없이는 충족하기 어렵다.
        - 이 클래스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

## 가비지 컬렉션 알고리즘

가비지 컬렉션 알고리즘을 구현하는 데는 수많은 기법이 활용되며 가상 머신 또는 플랫폼에 따라 차이가 많다.

객체의 생사를 판별하는 방식을 기준으로 가비지 컬렉션 알고리즘을 2가지로 나눌 수 있다.

- **참조 카운팅 GC (직접 가비지 컬렉션)**
- **추적 GC (간접 가비지 컬렉션)**

여기서는 추적 GC에 속한 알고리즘만 소개한다.

### 세대 단위 컬렉션 이론

현재 상용 가상 머신들이 채택한 가비지 컬렉터는 대부분 세대 단위 컬렉션 이론에 기초해 설계되었다. 세대 단위 컬렉션 이론의 본질은 대다수 프로그램에서 관측된 실제 상황들에서 얻은 경험 법칙을 구현한 것이다. 기본적으로 다음 두 가지 가정이 뿌리를 이룬다.

1. 약한 세대 가설(weak generational hypothesis) : 대다수 객체는 일찍 죽는다.
2. 강한 세대 가설(strong generational hypothesis) : 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
3. 세대 간 참조 가설(intergenerational reference hypothesis) : 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

이 두 가정이 합쳐셔 널리 알려진 가비지 컬렉터들에 일관된 설계 원칙을 제공한다. 자바 힙을 몇 개의 영역으로 나누고 객체들을 **나이(가비지 컬렉션에서 살아남은 횟수)**에 따라 각기 다른 영역에 할당하는 것이다.

자바 힙을 여러 영역으로 나누면 가비지 컬렉터는 한 번에 하나 또는 몇 개 영역만 선택해 회수할 수 있는데 이를 기준으로 **마이너 GC, 메이저 GC, 전체 GC** 식으로 부른다. 각 영역에 담긴 객체들의 생존 특성에 따라 마크-스윕(mark-sweep), 마크-카피(mark-copy), 마크-컴팩트(mark-compact) 등의 가비지 컬렉션 알고리즘을 구분해 적용한다.

- 부분 GC : 자바 힙의 일부만 회수하는 가비지 컬렉션
    - 마이너 GC (또는 신세대 GC) : 신세대만 대상으로 하는 가비지 컬렉션
    - 메이저 GC (또는 구세대 GC) : 구세대만 대상으로 하는 가비지 컬렉션 (CMS 컬렉터만 구세대를 따로 회수)
    - 혼합 GC : 신세대 전체와 구세대 일부를 대상으로 하는 가비지 컬렉션 (G1 컬렉터)
- 전체 GC : 자바 힙 전체와 메서드 영역까지 모두를 대상으로 하는 가비지 컬렉션

### 마크-스윕 알고리즘

최초이자 가장 기본적인 가비지 컬렉션 알고리즘이다. 작업을 **표시(mark)**와 **쓸기(sweep)**라는 두 단계로 나눠 진행한다. 먼저 회수할 객체들에 모두 표시한 다음, 표시된 객체들을 쓸어 담는 식이다. 또는 반대로 살릴 객체에 표시하고 표시되지 않은 객체를 회수하기도 한다.

마크-스윕이 가장 기본적인 알고리즘인 이유는 뒤이어 나온 컬렉션 알고리즘들 대부분이 이를 기초로 그 단점을 보완하는 식으로 발전했기 때문이다. 마크-스윕 알고리즘의 큰 단점은 두 가지다.

1. 실행 효율이 일정하지 않다.
    - 자바 힙이 다량의 객체로 가득 차 있고 그 대부분이 회수 대상이라면 표시하는 일도, 회수하는 일도 모두 커진다. 즉, 객체가 많아질수록 표시하고 쓸어 담는 작업의 효율이 떨어지는 구조다.
2. 메모리 파편화가 심하다.
    - 가비지 컬렉터가 쓸고 간 자리에는 불연속적인 메모리 파편이 만들어진다. 파편화가 너무 심하면 프로그램이 큰 객체를 만들려 할 때 충분한 크기의 연속된 메모리를 찾기가 점점 어려워지고, 그 결과 또 다른 가비지 컬렉션을 유발한다.
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/b3480655-571e-4470-be1b-8e3ba67d86c5/image.png)
    

### 마크-카피 알고리즘

간단히 카피 알고리즘이라고도 한다. 이 알고리즘은 가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 번에 한 블록만 사용한다. 한쪽 블록이 꽉 차면 살아남은 객체들만 다른 블록에 복사하고 기존 블록을 한 번에 청소한다.

대다수 객체가 살아남는다면 메모리 복사에 상당한 시간을 허비하는 반면, 대다수가 회복한다면 생존한 소수의 객체만 복사하면 된다. 더욱이 복사 과정에서 객체들이 메모리의 한쪽 끝에서부터 차곡차곡 쌓이기 때문에 골치 아픈 메모리의 파편화 문제로부터 해방된다.

이 알고리즘은 구현하기 쉽고 실행 효율도 좋다. 하지만 가용 메모리를 절반으로 줄여 낭비가 심하다는 단점이 있다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/a0b4f519-12f3-4184-a453-1be4edf3e35e/image.png)

오늘날 상용 자바 가상 머신 대부분은 신세대에 이 알고리즘을 활용한다. IBM은 **객체들의 생존 기간이 짧다**는 신세대의 특성을 이용한 연구를 수행한 결과 신세대 객체 중 98%가 첫 번째 가비지 컬렉션에서 살아남지 못했다. 즉, **신세대용 메모리 영역을 1:1로 나눌 필요가 없다는 결론**이다.

이 특성을 반영해 더 최적화된 전략을 **아펠 스타일 컬렉션**이라고 하며, 시리얼과 파뉴 같은 핫스팟 가상 머신의 신세대 컬렉터는 모두 신세대 메모리의 레이아웃을 이 전략에 부합하게 구성한다.

**아펠 스타일 컬렉션 방식**

1. 먼저 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 나눈다.
2. 메모리를 할당할 때는 생존자 공간 중 하나와 에덴만 사용한다.
3. 가비지 컬렉션이 시작되면 에덴과 생존자 공간에서 살아남은 객체들을 나머지 생존자 공간으로 하나씩 복사한 후 에덴과 이전 생존자 공간을 곧바로 비운다.

핫스팟 가상 머신에서 에덴과 생존자 공간의 비율은 기본적으로 8:1이다. 즉, 신세대에 할당된 전체 메모리 중 90%를 활용한다 (에덴 80% + 생존자 공간 중 하나 10%). 낭비하는 공간은 단 10% 뿐이다.

98%의 객체가 회수된다는 데이터는 물론 **일반적인 상황**에서 측정된 결과라서, 10% 넘게 살아남는 일이 절대 없다고 단정할 수 없다. 그래서 아펠 스타일 컬렉션에서도 10%가 넘는 특이 케이스에 대처하기 위해 메모리 할당 보증이라는 메커니즘이 있다. 마이너 GC에서 살아남은 객체를 생존자 공간이 다 수용하지 못할 경우 다른 메모리 영역(대부분의 경우 구세대)을 활용해 메모리 할당을 보증하는 것이다 (핸들 승격).

### 마크-컴팩트 알고리즘

마크-카피 알고리즘은 객체 생존율이 높을수록 복사할 게 많아져서 효율이 나빠진다. 더구나 공간을 50%나 낭비하기 싫다면 할당 보증용 공간을 따로 마련하여 대다수 객체가 살아남는 극단적 상황에 대처해야 한다. 그래서 구세대에는 적합하지 않다.

마크-컴팩트 알고리즘의 표시 단계는 마크-스윕과 같지만 다음 컴팩트 단계에서 (회수 대상 객체들을 곧바로 쓸어 담는 대신) 생존한 모든 객체를 메모리 영역의 한쪽 끝으로 모은 다음, 나머지 공간을 한꺼번에 비운다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/e90b45a1-ac2f-4a7a-991e-501680189691/image.png)

마크-스윕과의 핵심적인 차이는 메모리 이동이 일어난다는 점이다. 그런데 가비지 컬렉션 후 살아남은 객체를 이동할지는 양날의 검과 같은 결정이다. 특히 구세대에서는 회수 때마다 살아남는 객체가 상당히 많을 것이다. 따라서 생존한 객체를 이동시킨 후, 이동된 객체들을 가리키던 기존 참조들을 모두 갱신하기는 매우 부담될 것이다. 더욱이 이런 식의 객체 이동은 사용자 애플리케이션을 모두 멈춘 상태에서 진행해야 하므로 아주 신중하게 고려해야 할 단점이다. 이와 같은 일시 정지 현상을 **stop the world** 라고 한다.

## 핫스팟 알고리즘 상세 구현

### 루트 노드 열거

효율적인 가상 머신 구현하기의 첫 번째 예로 루트 노드 열거(root node enumeration)를 알아보자.

루트 노드 열거란 도달 가능성 분석 알고리즘에서 GC 루트 집합으로부터 참조 체인을 찾는 작업을 말한다. GC  루트로 고정할 수 있는 노드는 주로 전역 참조(상수와 클래스 정적 속성 등)와 실행 콘텍스트(스택 프레임의 지역 변수 테이블 등)에 존재한다. 목표는 명백하지만 참조 체인 스캔 과정을 효율적으로 구현하기는 만만치 않다.

지금까지 모든 컬렉터는 루트 노드 열거 단계에서 사용자 스레드를 일시 정지해야 했다. 루트 노드를 열거하려면 **stop the world**를 피할 수 없다는 이야기다.

현재 도달 가능성 분석 알고리즘의 참조 체인 찾기 과정에서 가장 오래 걸리는 작업은 다행히도 사용자 스레드와 동시에 실행할 수 있다. 하지만 **루트 노드 열거** 만큼은 반드시 일관성이 보장되는 스냅숏 상태에서 수행해야 한다. 여기서 **일관성**이란 열거 작업이 진행되는 동안 실행 서브시스템이 **특정 시점으로 고정**된 것처럼 보인다는 뜻이다. 더 구체적으로 표현하면 루트 노드들의 참조 관계가 변하지 않아야 한다는 말이다. 이 조건을 지키지 못하면 분석 결과를 신뢰할 수 없다.

이것이 가비지 컬렉션 시 모든 사용자 스레드가 일시 정지해야 하는 이유다. 심지어 일시 정지 기간을 제어할 수 있거나 (거의) 정지하지 않는 CMS, G1, ZGC 같은 컬렉터들도 루트 노드를 열거할 때만큼은 일시 정지를 피할 수 없다.

현재 주류 자바 가상 머신들은 **정확한 가비지 컬렉션**을 사용한다. 따라서 사용자 스레드가 정지한 후 실행 콘텍스트와 전역 참조의 위치를 빠짐없이 확인할 필요가 없다. 그 대신 가상 머신이 객체 참조가 저장된 위치를 직접 알아낼 방법이 있어야 한다.

핫스팟은 **OopMap**이라는 데이터 구조를 이용해 이 문제를 해결한다. 먼저 클래스 로딩이 완료되면 객체에 포함된 각 데이터의 타입을 확인한다. 그리고 JIT 컴파일 과정에서 스택의 어느 위치와 어느 레지스터의 데이터가 참조인지 기록한다. 이런 식으로 컬렉터는 메서드 영역과 다른 GC 루트들로부터 시작하여 추적해 보지 않고도 스캔 과정에서 이 정보를 직접 얻어 낸다.

### 안전 지점

핫스팟은 **OopMap**을 활용하여 GC 루트들을 빠르고 정확하게 열거할 수 있다. 하지만 진짜 큰 문제가 뒤따른다. 참조 관계나 OopMap의 내용을 변경할 수 있는 명령어가 많으며, 이런 명령어 모두에 OopMap을 만들어 넣으면 메모리를 더 많이 사용해야 한다. 실제로 가비지 컬렉션에 드는 공간 비용을 감당하기 어려울 만큼 커진다.

그래서 핫스팟은 모든 명령어 각각에 OopMap을 생성하지는 않는다. 그 대신 **안전 지점(safe point)**이라고 하는 특정한 위치에만 기록한다. 가비지 컬렉터는 사용자 프로그램이 안전 지점에 도달할 때까지는 절대 멈춰 세우지 않는다. 따라서 안전 지점을 너무 적게 설정해서 컬렉터가 너무 오래 기다리게 하거나, 반대로 너무 많이 설정해서 런타임 메모리 부하가 지나치게 커지지 않도록 주의해야 한다.

### 5.2.1 대용량 메모리 기기 대상 배포 전략

> 사례 1

하드웨어 시스템을 스펙업하여 자바 힙 크기를 12GB로 설정했다. 하지만 서버 실행 효율이 기대에 한참 못 미치고, 웹 서비스가 장시간 응답하지 않는 일이 자주 벌어졌다.

응답이 지연되는 원인은 가비지 컬렉션이었고, 서버 모드로 실행한 핫스팟 가상 머신의 기본 설정은 패러렐 컬렉터였다. 패러렐 컬렉터는 일시 정지 시간보다는 처리량에 중점을 둔 컬렉터였기 때문에 12GB에 달하는 힙 메모리를 전체 GC하기 위해 최장 14초까지 일시 정지했던 것이다.
> 

자바 가상 머신의 모든 가비지 컬렉터는 특정한 애플리케이션 타입과 동작 시나리오를 목표로 설계되었다. 따라서 애플리케이션을 시나리오에 알맞게 설정하여 배포한다면 좋은 효과를 얻을 수 있다.

**현재 대용량 메모리를 갖춘 하드웨어에 단일 자바 애플리케이션을 배포하는 주된 방식**

1. 가상 머신 인스턴스 하나가 거대한 자바 힙 메모리를 관리한다.
2. 가상 머신 여러 개를 동시에 띄워 논리적인 클러스터를 구성한다.

**1번 방식**

사례 1은 사용자와 상호 작용이 많고 일시 정지 시간에 민감하고 대용량 메모리를 갖추고 있어서 셰넌도어나 ZGC처럼 지연 시간 통제를 목표로 하는 가비지 컬렉터를 이용하면 이 문제를 해결할 수 있다.

**2번 방식** 

패러렐 컬렉터로 대량의 힙을 성공적으로 관리하는 사례도 많다.

- 전체 GC 빈도를 가능한 낮게, 적어도 사용자가 이용하는 도중에는 일어나지 않게 제어해야 한다.
    - ex) 전체 GC 없이 하루 이상 가동될 수 있도록 만들어 두고, 매일 새벽에 전체 GC를 수행하거나 애플리케이션 서버를 자동으로 재시작하도록 스케줄링한다.

### 5.2.2 클러스터 간 동기화로 인한 메모리 오버플로

> 사례 2

서버 클러스터링을 구성한 후 공유 데이터를 DB로 관리했지만 성능에 미치는 영향이 커서 JBossCache로 글로벌 캐시를 구축했다. 서비스가 원활하게 운영되었지만 시간이 지나 메모리 오버플로가 가끔 발생하기 시작했다.

특정 상황에서 네트워크가 데이터 전송량을 다 처리하지 못하게 되면 재전송된 데이터가 메모리에 계속 쌓이다가 오버플로가 발생한 것이었다.
> 

위 사례처럼 클러스터 전체에서 공유해야 하는 데이터를 JBossCache 같은 분산 클러스터 캐시를 이용해 동기화하면 네트워크 통신이 자주 일어날 수 있다. 다행히 로컬 메모리에 복사본을 두기 때문에 읽기 작업에는 자원을 많이 소비하지 않지만, 쓰기는 네트워크 동기화 오버헤드를 일으키므로 너무 빈번하게 해서는 안 된다.

# 예외

JdbcTemplate을 대표로 하는 스프링의 데이터 액세스 기능에 담겨 있는 예외처리와 관련된 접근 방법에 대해 알아본다. 이를 통해 예외를 처리하는 베스트 프랙티스도 살펴본다.

### 예외의 종류와 특징

- **Error** : java.lang.Error 클래스의 서브클래스들이다. 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다. 주로 JVM에서 발생시키는 것이고 애플리케이션 코드에서는 대응 방법이 없다. 따라서 시스템 레벨에서 특별한 작업을 하는 게 아니라면 애플리케이션에서는 이런 에러에 대한 처리는 신경 쓰지 않아도 된다.
- **Exception과 체크 예외** : java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.
    - **체크 예외(checked exception)** : Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 클래스들
        - 체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 사용할 메서드가 체크 예외를 던진다면 이를 catch 문으로 잡든지, 아니면 다시 throws를 정의해서 메서드 밖으로 던져야 한다. (예외처리 하지 않으면 컴파일 에러 발생)
    - **언체크 예외(unchecked exception)** : RuntimeException을 상속한 클래스들

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/8b29c73c-e425-475d-a24a-fb12fda1a454/image.png)

### 예외처리 방법

**예외복구**

첫 번째 예외처리 방법은 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다. IOException 예외발생했을 때 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내해서 예외상황을 해결할 수 있다. 예외로 인해 기본 작업 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도해주는 것이다.

**예외처리 회피**

두 번째 방법은 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것이다. throws 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch 문으로 일단 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는 것이다.

**예외 전환**

마지막으로 예외를 처리하는 방법은 예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메서드 밖으로 던지는 것이다. 하지만 예외 회피와 달리, 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다는 특징이 있다.

예외 전환은 보통 두 가지 목적으로 사용된다.

1. 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대해 적절한 의미를 부여해주지 못하는 경우에, 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해 사용된다.
    - 예를 들어 새로운 사용자를 등록하려고 시도할 때, 같은 아이디가 있어 SQLException이 발생하면 왜 발생했는지 모를 것이다. 이때 중복된 아이디가 있다는 예외로 전환해서 던져줄 때 사용한다.
    - 보통 전환하는 예외에 원래 발생한 예외를 담아서 **중첩 예외(nested exception)**로 만드는 것이 좋다. 중첩 예외는 `getCause()` 메서드를 이용해서 처음 발생한 예외가 무엇인지 확인할 수 있다.
    
    ```java
    // 방법 1
    catch(SQLException e) {
    ...
    throw DuplicateUserIdException(e);
    }
    
    // 방법 2
    catch(SQLException e) {
    ...
    throw DuplicateUserIdException().initCause(e);
    }
    ```
    

1. 예외를 처리하기 쉽고 단순하게 만들기 위해 포장(wrap)하는 것이다. 중첩 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 방식은 같다. 하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니다. 주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다.

### JDBC의 한계

JDBC는 자바 표준 JDK에서도 가장 많이 사용되는 기능 중의 하나다. JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고, 각 DB 벤더사가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해준다. 하지만 표준화된 JDBC API가 DB를 사용하는 데 부담은 줄여주지만 DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 보장해주지는 못한다. 현실적으로 DB를 자유롭게 바꾸어 사용할 수 있는 DB 프로그램을 작성하는 데는 두 가지 걸림돌이 있다.

1. 비표준 SQL
    - 대부분의 DB는 비표준 문법과 기능을 제공하며, 매우 폭넓게 사용된다. 해당 DB의 특별한 기능을 사용하거나 최적화된 SQL을 만들 때 유용하기 때문이다. 하지만 비표준 문법과 기능은 해당 DB에 종속적이기 때문에 DB의 변경 가능성을 고려해서 유연하게 작성할 수 없다.
2. 호환성 없는 SQLException의 DB 에러정보
    - DB를 사용하다가 발생할 수 있는 예외의 원인은 다양하다. 문제는 DB마다 SQL만 다른 것이 아니라 에러의 종류와 원인도 제각각이라는 점이다. 그래서 JDBC는 모든 다양한 예외를 그냥 SQLException 하나에 모두 담아버린다. SQLException 안에 담긴 에러 코드와 SQL 상태 정보도 모두 DB 벤더사마다 다르다.

### DAO 인터페이스와 구현의 분리

DAO를 굳이 따로 만들어서 사용하는 이유는 뭘까?

- 가장 중요한 이유는 데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위해서다.
- 분리된 DAO는 전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있게 만들기 위해서이기도 하다. DAO를 사용하는 쪽에서는 DAO의 내부 구현을 신경 쓰지 않고 사용하기만 하면 된다. 그런 면에서 DAO는 인터페이스를 사용해 구체적인 클래스 정보와 구현 방법을 감추고, DI를 통해 제공되도록 만드는 것이 바람직하다.

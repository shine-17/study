# 2장 테스트

스프링은 IoC/DI를 이용해 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와주는 기술이다. 동시에 스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술이기도 하다. 이러한 복잡한 애플리케이션을 개발하는 데 필요한 도구는 **객체지향**과 **테스트**다.

테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

`UserDatoTest`는 한 가지 관심에 집중할 수 있게 작은 단위로 만들어진 테스트다. `UserDatoTest` 의 테스트를 수행할 때는 웹 인터페이스나, 그것을 위한 MVC 클래스, 서비스 오브젝트 등이 필요없다. 서버에 배포할 필요도 없고 간단히 IDE나 도스창에서도 테스트 수행이 가능하다. 만약 에러가 나거나 원치 않는 결과가 나온다면, 그것은 `UserDao` 코드나 DB 연결 방법 정도에서 문제가 있는 것이니 원인을 빠르게 찾아낼 수 있다.

- main() 메서드를 통해 `UserDaoTest` 를 테스트할 경우 `UserDaoTest` 가 의존하는 다른 클래스나 인터페이스를 모두 구현해야 테스트가 가능하다는 큰 단점이 있다.

이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트(unit test)**라고 한다. 여기서 말하는 단위란 무엇인지, 그 크기와 범위가 어느 정도인지 딱 정해진 것은 아니다. 크게는 사용자 관리 기능을 모두 통틀어서 하나의 단위로 볼 수도 있고, 작게 보자면 `UserDao`의 `add()` 메서드 하나만 단위로 생각할 수도 있다. **충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위**라고 보면 된다.

### `UserDaoTest`의 문제점

- 수동 확인 작업의 번거로움 : 사람의 눈으로 직접 확인 필요
- 실행 작업의 번거로움 : `main()` 메서드 반복 실행 필요

## 테스팅 프레임워크 JUnit

`UserDaoTest`의 `main()` 메서드는 제어권을 직접 갖는다는 의미이기 때문에 프레임워크에 적용하기엔 적합하지 않다. 그래서 가장 먼저 할 일은 `main()` 메서드에 있던 테스트 코드를 일반 메서드로 옮기는 것이다. 새로 만들 테스트 메서드는 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 한다.

1. 메서드가 **public**으로 선언되어야 한다.
2. 메서드에 **@Test** 애노테이션이 붙어있어야 한다.

```java
public class UserDaoTest {
	@Test
	public void addAndGet() throws SQLException {
		...
	}
}
```

**주의할 점**

JUnit은 특정한 테스트 메서드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.

### 테스트 주도 개발

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법을 **테스트 주도 개발(TDD, Test Driven Development)**이라고 한다.

TDD는 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있다. **실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다**는 것이 TDD의 기본 원칙이다. 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.

테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다. 그러려면 테스트없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다. 테스트를 먼저 만들어두면 코딩이 끝나자마자 바로 테스트를 실행할 수 있으니 가장 좋은 방법이다.

### JUnit의 테스트 수행 방식

1. 테스트 클래스에서 `@Test`가 붙은 `public`이고 `void`형이며 파라미터가 없는 테스트 메서드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. `@Before`가 붙은 메서드가 있으면 실행한다.
4. `@Test`가 붙은 메서드를 하나 호출하고 테스트 결과를 저장해둔다.
5. `@After`가 붙은 메서드가 있으면 실행한다.
6. 나머지 테스트 메서드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/2436deb0-d33c-42b9-9d0b-57359cf9932d/image.png)

왜 테스트 메서드를 실행할 때마다 새로운 오브젝트를 만들까? 그냥 테스트 클래스마다 하나의 오브젝트만 만들어놓고 사용하는 편이 성능도 낫고 더 효율적이지 않을까?

- 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 한 것이다. 덕분에 인스턴스 변수도 부담 없이 사용할 수 있다. 어차피 다음 테스트 메서드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화될 것이다.

테스트 메서드의 일부에서만 공통적으로 사용되는 코드가 있을 때는 `@Before` 를 사용하기보다, 일반적인 메서드 추출 방버을 써서 메서드를 분리해서 테스트 메서드에서 직접 호출하도록 사용하는 편이 낫다. 아니면 아예 공통적인 특징을 지닌 테스트 메서드를 모아서 별도의 테스트 클래스로 만드는 방법도 생각해볼 수 있다.

### 픽스처

테스트를 수행하는 데 필요한 정보나 오브젝트를 **픽스처(fixture)**라고 한다. 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 `@Before` 메서드를 이용해 생성해두면 편리하다. `UserDaoTest`에서라면 `dao`가 대표적인 픽스처다.

### 테스트를 위한 애플리케이션 컨텍스트 관리

스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 테스트 컨텍스트의 지원을 받으면 간단한 애노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

```java
@Runwith(SpringJUnit4ClassRunner.class) // 1
@ContextConfiguration(locations="/applicationContext.xml") // 2
public class UserDaoTest {
	@Autowired
	private ApplicationContext context; // 3

	...
}
```

1. 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능 지정
2. 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
3. 테스트 오브젝트가 만들어지고 나면 스프링 테스트 컨텍스트에 의해 자동으로 값이 주입된다.

`@Runwith`는 JUnit의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다. `SpringJUnit4ClassRunner`는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.

`@ContextConfiguration`은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한 것이다.

# 2장 테스트

스프링은 IoC/DI를 이용해 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와주는 기술이다. 동시에 스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술이기도 하다. 이러한 복잡한 애플리케이션을 개발하는 데 필요한 도구는 **객체지향**과 **테스트**다.

테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업이다.

`UserDatoTest`는 한 가지 관심에 집중할 수 있게 작은 단위로 만들어진 테스트다. `UserDatoTest` 의 테스트를 수행할 때는 웹 인터페이스나, 그것을 위한 MVC 클래스, 서비스 오브젝트 등이 필요없다. 서버에 배포할 필요도 없고 간단히 IDE나 도스창에서도 테스트 수행이 가능하다. 만약 에러가 나거나 원치 않는 결과가 나온다면, 그것은 `UserDao` 코드나 DB 연결 방법 정도에서 문제가 있는 것이니 원인을 빠르게 찾아낼 수 있다.

- main() 메서드를 통해 `UserDaoTest` 를 테스트할 경우 `UserDaoTest` 가 의존하는 다른 클래스나 인터페이스를 모두 구현해야 테스트가 가능하다는 큰 단점이 있다.

이렇게 작은 단위의 코드에 대해 테스트를 수행한 것을 **단위 테스트(unit test)**라고 한다. 여기서 말하는 단위란 무엇인지, 그 크기와 범위가 어느 정도인지 딱 정해진 것은 아니다. 크게는 사용자 관리 기능을 모두 통틀어서 하나의 단위로 볼 수도 있고, 작게 보자면 `UserDao`의 `add()` 메서드 하나만 단위로 생각할 수도 있다. **충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위**라고 보면 된다.

### `UserDaoTest`의 문제점

- 수동 확인 작업의 번거로움 : 사람의 눈으로 직접 확인 필요
- 실행 작업의 번거로움 : `main()` 메서드 반복 실행 필요

## 테스팅 프레임워크 JUnit

`UserDaoTest`의 `main()` 메서드는 제어권을 직접 갖는다는 의미이기 때문에 프레임워크에 적용하기엔 적합하지 않다. 그래서 가장 먼저 할 일은 `main()` 메서드에 있던 테스트 코드를 일반 메서드로 옮기는 것이다. 새로 만들 테스트 메서드는 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 한다.

1. 메서드가 **public**으로 선언되어야 한다.
2. 메서드에 **@Test** 애노테이션이 붙어있어야 한다.

```java
public class UserDaoTest {
	@Test
	public void addAndGet() throws SQLException {
		...
	}
}
```

**주의할 점**

JUnit은 특정한 테스트 메서드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.

### 테스트 주도 개발

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법을 **테스트 주도 개발(TDD, Test Driven Development)**이라고 한다.

TDD는 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있다. **실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다**는 것이 TDD의 기본 원칙이다. 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.

테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다. 그러려면 테스트없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다. 테스트를 먼저 만들어두면 코딩이 끝나자마자 바로 테스트를 실행할 수 있으니 가장 좋은 방법이다.

### JUnit의 테스트 수행 방식

1. 테스트 클래스에서 `@Test`가 붙은 `public`이고 `void`형이며 파라미터가 없는 테스트 메서드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. `@Before`가 붙은 메서드가 있으면 실행한다.
4. `@Test`가 붙은 메서드를 하나 호출하고 테스트 결과를 저장해둔다.
5. `@After`가 붙은 메서드가 있으면 실행한다.
6. 나머지 테스트 메서드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/2436deb0-d33c-42b9-9d0b-57359cf9932d/image.png)

왜 테스트 메서드를 실행할 때마다 새로운 오브젝트를 만들까? 그냥 테스트 클래스마다 하나의 오브젝트만 만들어놓고 사용하는 편이 성능도 낫고 더 효율적이지 않을까?

- 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 한 것이다. 덕분에 인스턴스 변수도 부담 없이 사용할 수 있다. 어차피 다음 테스트 메서드가 실행될 때는 새로운 오브젝트가 만들어져서 다 초기화될 것이다.

테스트 메서드의 일부에서만 공통적으로 사용되는 코드가 있을 때는 `@Before` 를 사용하기보다, 일반적인 메서드 추출 방버을 써서 메서드를 분리해서 테스트 메서드에서 직접 호출하도록 사용하는 편이 낫다. 아니면 아예 공통적인 특징을 지닌 테스트 메서드를 모아서 별도의 테스트 클래스로 만드는 방법도 생각해볼 수 있다.

### 픽스처

테스트를 수행하는 데 필요한 정보나 오브젝트를 **픽스처(fixture)**라고 한다. 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 `@Before` 메서드를 이용해 생성해두면 편리하다. `UserDaoTest`에서라면 `dao`가 대표적인 픽스처다.

### 테스트를 위한 애플리케이션 컨텍스트 관리

스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 테스트 컨텍스트의 지원을 받으면 간단한 애노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

**테스트 컨텍스트 프레임워크** : 테스트에 사용되는 애플리케이션 컨텍스트를 생성하고 관리하여 테스트에 적용해주는 테스트 프레임워크

```java
@Runwith(SpringJUnit4ClassRunner.class) // 1
@ContextConfiguration(locations="/applicationContext.xml") // 2
public class UserDaoTest {
	@Autowired
	private ApplicationContext context; // 3

	...
}
```

1. 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능 지정
2. 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정
3. 테스트 오브젝트가 만들어지고 나면 스프링 테스트 컨텍스트에 의해 자동으로 값이 주입된다.

`@Runwith`는 JUnit의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다. `SpringJUnit4ClassRunner`는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.

`@ContextConfiguration`은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한 것이다.

스프링 테스트 컨텍스트 프레임워크는 위 코드처럼 하나의 테스트 클래스 내에서만 애플리케이션 컨텍스트를 공유해줄 뿐만 아니라 여러 테스트 클래스 내에서도 공유하게 해준다.

### @Autowired

1. @Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다.
2. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.
    - 일반적으로 주입을 위해서는 생성자나 수정자 메서드가 필요하지만 이 경우에는 메서드가 없어도 주입이 가능하다.

그런데 위의 테스트 코드에서는 `applicationContext.xml` 파일에 정의된 빈이 아니라, `ApplicationContext` 타입의 변수에 `@Autowired` 를 붙였는데 애플리케이션 컨텍스트가 DI 됐다.

어떻게 됐을까?

스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 따라서 애플리케이션 컨텍스트에는 `ApplicationContext` 타입의 빈이 존재하고 DI도 가능한 것이다.

`@Autowired`를 이용해 애플리케이션 컨텍스트가 갖고 있는 빈을 DI 받을 수 있다면 굳이 컨텍스트를 가져와 `getBean()` 을 사용하는 것이 아니라, 아예 UserDao 빈을 직접 DI 받을 수도 있을 것이다.

```java
public class UserDaoTest {
	@Autowired
	UserDao dao; // UserDao 타입 빈을 직접 DI 받는다.
}
```

@Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다. 단 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없어서 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 찾을 수 없는 경우에는 예외가 발생한다.

테스트 코드는 필요하다면 얼마든지 애플리케이션 클래스와 밀접한 관계를 맺고 있어도 상관없지만, 꼭 필요하지 않는다면 테스트 코드에서도 가능한 한 인터페이스를 사용해서 애플리케이션 클래스와 느슨하게 연결해두는 편이 좋다.

### 테스트 코드에 의한 DI

테스트 코드에서 DB를 이용한 테스트가 필요할 경우 운영 DB 대신 테스트 DB로 테스트할 경우다.

테스트 코드에 테스트 DB를 DI 적용한 코드다.

```java
@DirtiesContext // 1
public class UserDaoTest {
	@Autowired
	UserDao dao;
	
	@Before
	public void setUp() {
		...
		DataSource dataSource = new SingleConnectionDataSource(...); // 2
		
		dao.setDataSource(dataSource); // 3
	}
}
```

1. 테스트 메서드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트에 알려준다.
2. 테스트에서 UserDao가 사용할 DataSource 오브젝트를 직접 생성한다. SingleConnectionDataSource는 스프링에서 제공하는 가장 빠른 DataSource이다. DB 커넥션을 하나만 만들어두고 계속 사용하기 때문에 매우 빠르다. 다중 사용자 환경에서는 사용할 수 없겠지만 순차적으로 진행되는 테스트에서는 문제없다.
3. 코드에 의한 수동 DI

이 방법의 장점은 XML 설정파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다는 것이다. (수동 DI)

하지만 이 방식은 매우 주의해서 사용해야 한다. 이미 애플리케이션 컨텍스트에서 `applicationContext.xml` 파일의 설정정보를 따라 구성한 오브젝트를 가져와 의존관계를 강제로 변경했기 때문이다.

테스트 컨텍스트를 적용했다면 애플리케이션 컨텍스트는 테스트 중에 딱 한 개만 만들어지고 모든 테스트에서 공유해서 사용한다. 따라서 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는 것이 원칙이다.

그런데 위 테스트 코드는 애플리케이션 컨텍스트에서 가져온 `UserDao` 빈의 의존관계를 강제로 변경한다. 한 번 변경하면 나머지 모든 테스트를 수행하는 동안 변경된 애플리케이션 컨텍스트가 계속 공유되어 사용될 것이다.

그래서 `UserDaoTest`에는 `@DirtiesContext` 애노테이션을 추가해줬다. 이 애노테이션은 테스트 컨텍스트에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. 테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 테스트 메서드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트가 사용하게 해준다. **테스트 중에 변경한 컨텍스트가 뒤의 테스트에 영향을 주지 않게 하기 위해서다.**

> `@DirtiesContext`는 클래스에만 적용할 수 있는 건 아니다. 하나의 메서드에서만 컨텍스트 상태를 변경한다면 메서드 레벨에 붙여주는 편이 낫다. 해당 메서드의 실행이 끝나고 나면 이후에 진행되는 테스트를 위해 변경된 애플리케이션 컨텍스트는 폐기되고 새로운 애플리케이션 컨텍스트가 만들어진다.
> 

### 테스트를 위한 별도의 DI 설정

위 방법은 장점보다 단점이 많다. 위 방법 말고도 다른 방법은 없을까?

테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어 테스트 코드에서 해당 설정파일을 사용하면 된다.

기존의 applicationContext.xml 을 복사하여 test-applicationContext.xml로 변경한 뒤 빈 설정을 테스트 DB에 맞게 설정해주고 테스트 코드에서 해당 설정파일을 사용하도록 코드를 작성하면 된다.

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/test-applicationContext.xml")
public class UserDaoTest {
```

### 컨테이너 없는 DI 테스트

```java
public class UserDaoTest {
	UserDao dao; // @Autowired가 없다.
	...
	
	@Before
	public void setUp(
		...
		dao = new UserDao();
		DataSource dataSource = new SingleConnectionDataSource(...);
		dao.setDataSource(dataSource);
		// setUp()에서 오브젝트 생성, 관계설정 등을 모두 직접 해준다.
	}
	
}
```

테스트를 위한 DataSource를 직접 만드는 번거로움은 있지만 애플리케이션 컨텍스트를 아예 사용하지 않으니 코드는 더 단순해지고 이해하기 편해졌다. 하지만 JUnit은 매번 새로운 테스트 오브젝트를 만들기 때문에 매번 새로운 UserDao 오브젝트가 만들어진다는 단점도 있다.

`UserDao`는 스프링의 API에 의존하지 않고 자신의 관심에만 집중해서 깔끔하게 만들어진 코드이다. 바로 이런 가볍고 깔끔한 테스트를 만들 수 있는 이유도 DI를 적용했기 때문이다. DI는 객체지향 프로그래밍 스타일이다. 따라서 DI를 위해 컨테이너가 반드시 필요한 것은 아니다. **DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다.**

> **침투적 기술과 비침투적 기술**
침투적(invasive) 기술은 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나, 특정 인터페이스나 클래스를 사용하도록 강제하는 기술을 말한다. 침투적 기술을 사용하면 애플리케이션 코드가 해당 기술에 종속되는 결과를 가져온다.
반면에 비침투적(noninvasive) 기술은 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능하다. 따라서 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 해준다. 스프링은 이런 비침투적 기술의 대표적인 예다. 그래서 스프링 컨테이너 없는 DI 테스트도 가능한 것이다.
> 

### DI를 이용한 테스트 방법 선택

- 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 우선적으로 고려
    - 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다.
    - 테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 먼저 고려
- 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트할 경우, 스프링의 설정을 이용한 DI 방식의 테스트를 이용
    - 테스트에서 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정파일을 따로 만들어 사용하는 편이 좋다.
- 테스트 설정을 따로 만들었다고 하더라도 가끔 예외적인 의존관계를 강제로 구성해서 테스트할 경우는 수동 DI 하는 방법을 사용한다. (`@DirtiesContext` 필수)

### 학습 테스트로 배우는 스프링

일반적으로 애플리케이션 개발자는 자신이 만들고 있는 코드에 대한 테스트만 작성하면 되지만, 때로는 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 한다. 이런 테스트를 **학습 테스트(learning test)**라고 한다.

학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다.

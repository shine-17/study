# 1장 오브젝트와 의존관계

스프링은 자바를 기반으로 한 기술이다. 스프링이 자바에서 가장 중요하게 가치를 두는 것은 객체지향 프로그래밍이 가능한 언어라는 점이다. 자바 엔터프라이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고, 그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이 스프링의 핵심 철학이다.

그래서 스프링이 가장 관심을 많이 두는 대상은 오브젝트다. 스프링을 이해하려면 먼저 오브젝트에 깊은 관심을 가져야 한다. 애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고, 소멸하기까지의 전 과정을 진지하게 생각해볼 필요가 있다. 더 나아가서 오브젝트는 어떻게 설계돼야 하는지, 어떤 단위로 만들어지며 어떤 과정을 통해 자신의 존재를 드러내고 등장해야 하는지에 대해서도 살펴봐야 한다.

결국 오브젝트에 대한 관심은 오브젝트의 기술적인 특징과 사용 방법을 넘어서 오브젝트의 설계로 발전하게 된다. 객체지향 설계의 기초와 원칙을 비롯해서, 다양한 목적을 위해 재활용 가능한 설계 방법인 디자인 패턴, 좀 더 깔끔한 구조가 되도록 지속적으로 개선해나가는 작업인 리팩토링, 오브젝트가 기대한 대로 동작하고 있는지를 효과적으로 검증하는 데 쓰이는 단위 테스트와 같은 오브젝트 설계와 구현에 관한 여러 가지 응용 기술과 지식이 요구된다.

스프링은 객체지향 설계와 구현에 관해 특정한 모델과 기법을 억지로 강요하지는 않는다. 하지만 오브젝트를 어떻게 효과적으로 설계하고 구현하고, 사용하고, 이를 개선해나갈 것인가에 대한 명쾌한 기준을 마련해준다. 동시에 스프링은 객체지향 기술과 설계, 구현에 관한 실용적인 전략과 검증된 베스트 프랙티스를 평범한 개발자도 자연스럽고 손쉽게 적용할 수 있도록 프레임워크 형태로 제공한다.

---

## 1.1 초난감 DAO

사용자 정보를 JDBC API를 통해 DB에 저장하고 조회할 수 있는 간단한 DAO를 만들어보자

> **DAO (Data Access Object)**
DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트
> 

> **자바빈 (JavaBean)**
원래 비주얼 툴에서 조작 가능한 컴포넌트를 말한다. 자바의 주력 개발 플랫폼이 웹 기반의 엔터프라이즈 방식으로 바뀌면서 비주얼 컴포넌트로서 자바빈은 인기를 잃어갔지만, 자바빈의 몇 가지 코딩 관례는 JSP 빈, EJB와 같은 표준 기술과 자바빈 스타일의 오브젝트를 사용하는 오픈소스 기술을 통해 계속 이어져 왔다. 이제는 자바빈이라고 말하면 비주얼 컴포넌트라기보다는 다음 두 가지 관례를 따라 만들어진 오브젝트를 가리킨다. 간단히 빈이라고 부르기도 한다.

- 디폴트 생성자 : 자바빈은 파라미터가 없는 디폴트 생성자를 가지고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
- 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 한다. 프로퍼티는 set으로 시작하는 수정자 메서드(setter)와 get으로 시작하는 접근자 메서드(getter)를 이용해 수정 또는 조회할 수 있다.
> 

### 관심사의 분리

객체지향의 세계에서는 모든 것이 변한다. 소프트웨어 개발에서 끝이란 개념은 없으며 사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌고 발전한다.

그래서 개발자는 객체를 설계할 때 가장 염두에 둬야 할 사항은 **미래의 변화를 어떻게 대비할 것인가**이다.

변화는 먼 미래뿐만 아니라 가까운 미래에도 갑자기 발생할 수 있다.

그러면 어떻게 변경이 일어났을 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까?

바로 **분리와 확장**을 고려한 설계를 하면 된다.

먼저 분리에 대해 생각해보면, 변경에 대한 요청은 “DB를 오라클에서 MySQL로 바꾸면서, 웹 레이아웃을 다중 프레임에서 단일 프레임으로 바꾸고..” 이런 식으로 발생하지 않는다.

다시말해 **모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다**는 뜻이다.

문제는, 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 점이다.

“DB 비밀번호를 변경하려고 DAO 클래스 수백개를 변경해야 한다면? 트랜잭션 기술을 변경했다고 비즈니스 로직 구조를 모두 변경해야 한다면?”

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다.

즉 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

프로그래밍 기초 개념 중에 **관심사의 분리**라는 것을 객체지향에 적용해보면,

관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것이다.

관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어준다.

> **리팩토링**
기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술
리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 결국 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다. 리팩토링이 절실히 필요한 코드의 특징을 나쁜 냄새라고 부르기도 한다. 대표적으로 중복된 코드는 매우 흔하게 발견되는 나쁜 냄새다. 이런 코드는 적절한 리팩토링 방법을 적용해 나쁜 냄새를 제거해줘야 한다.

리팩토링은 개발자가 직관적으로 수행할 수 있긴 하지만, 본격적으로 적용하자면 학습과 훈련이 필요하다. 나쁜 냄새에는 어떤 종류가 있고 그에 따른 적절한 리팩토링 방법은 무엇인지 알아보고, 충분한 연습을 해두면 도움이 된다. 리팩토링을 공부할 때는 리팩토링에 관해 체계적으로 잘 정리한 책인 **리팩토링(마틴 파울러, 켄트 벡)**을 추천한다.
>

### 원칙과 패턴

**개방 폐쇄 원칙(OCP, Open-Closed Principle)**

> **클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다**
> 

개방 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/a67c1720-0466-4cb1-8961-24a7920985f5/image.png)

UserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열려 있다. UserDao에 전혀 영향을 주지 않고도 얼마든지 기능을 확장할 수 있게 되어 있다.

동시에 UserDao 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀 있다고 말할 수 있다.

## 1.4 제어의 역전(IoC)

제어의 역전이라는 건, 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 할 수 있다.

프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다.

라이브러리와 프레임워크는 차이가 있다.

- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.
    - 예 : Gson 라이브러리
- 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.
- 프레임워크에는 분명한 제어의 역전 개념이 적용되어 있어야 한다. 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다.
    - 예 : 스프링 프레임워크, JUnit 프레임워크

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/a67c1720-0466-4cb1-8961-24a7920985f5/image.png)

`UserDao`와 `DaoFactory`에도 제어의 역전이 적용되어 있다.

- 원래 `ConnectionMaker`의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 `UserDao`에게 있었다. 그런데 지금은 `DaoFactory`에게 있다.
- 자신이 어떤 `ConnectionMaker` 구현 클래스를 만들고 사용할지를 결정할 권한을 `DaoFactory`에 넘겼으니 `UserDao`는 이제 능동적이 아니라 수동적인 존재가 됐다.
- `UserDao` 자신도 팩토리에 의해 수동적으로 만들어지고 자신이 사용할 오브젝트도 `DaoFactory`가 공급해주는 것을 수동적으로 사용해야 할 입장이 됐다.
- `UserDaoTest`는 `DaoFactory`가 만들고 초기화해서 자신에게 사용하도록 공급해주는 `ConnectionMaker`를 사용할 수밖에 없다.
- 더욱이 `UserDao`와 `ConnectionMaker`의 구현체를 생성하는 책임도 `DaoFactory`가 맡고 있다.

바로 이것이 제어의 역전(IoC)가 일어난 상황이다.

## 1.5 스프링의 IoC

### 애플리케이션 컨텍스트와 설정정보

스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 **빈(bean)**이라고 한다.

자바빈 또는 엔터프라이즈 자바빈(EJB)에서 말하는 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트를 말한다.

동시에 **스프링 빈**은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 뜻한다.

스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(bean factory)라고 한다. 보통 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트(application context)를 사용한다. 애플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리라고 생각하면 된다.

두 가지는 동일하다고 생각하면 되지만 부각시키는 의미가 조금 다르다.

- 빈 팩토리 : 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춤
- 애플리케이션 컨텍스트 : 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진의 의미

**애플리케이션 컨텍스트**는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다. 기존 DaoFactory 코드에는 설정정보, 예를 들어 어떤 클래스의 오브젝트를 생성하고 어디에서 사용하도록 연결해줄 것인가 등에 관한 정보가 평범한 자바 코드로 만들어져 있다. **애플리케이션 컨텍스트**는 직접 이런 정보를 담고 있지 않고, 별도로 설정정보를 담고 있는 무엇인가를 가져와 이를 활용하는 범용적인 IoC 엔진같은 것이다.

**빈 팩토리** 또는 **애플리케이션 컨텍스트**가 사용하는 설정정보를 만드는 방법은 여러가지가 있다. 앞에서 만든 오브젝트 팩토리인 `DaoFactory`도 조금만 손을 보면 설정정보로 사용할 수 있다. 앞에서는 `DaoFactory` 자체가 설정정보까지 담고 있는 IoC 엔진이었는데 여기서는 자바 코드로 만든 **애플리케이션 컨텍스트**의 설정정보로 활용될 것이다. 

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/44900fa5-e6da-4da1-bb46-2b843b41d132/image.png)

위 그림에서 애플리케이션의 로직을 담고 있는 컴포넌트와 설계도 역할을 하는 팩토리를 구분했었다.

바로 이 설계도라는 게 애플리케이션 컨텍스트와 그 설정정보를 뜻한다. 그 자체로는 애플리케이션 로직을 담당하지는 않지만 IoC 방식을 이용해 애플리케이션 컴포넌트를 생성하고, 사용할 관계를 맺어주는 등의 책임을 담당하는 것이다. 마치 건물이 설계도면을 따라서 만들어지듯이, 애플리케이션도 애플리케이션 컨텍스트와 그 설정정보를 따라서 만들어지고 구성된다고 생각할 수 있다.

### DaoFactory를 사용하는 애플리케이션 컨텍스트

```java
@Configuration
public class DaoFactory {
    public DaoFactory() {
    }

    @Bean
    public UserDao userDao() {
        UserDao dao = new UserDao(this.connectionMaker());
        return dao;
    }

    @Bean
    public ConnectionMaker connectionMaker() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        return connectionMaker;
    }
}
```

- @Configuration : 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
- @Bean : 오브젝트 생성을 담당하는 IoC용 메서드라는 표시

### 애플리케이션 컨텍스트를 적용한 UserDaoTest

```java
public class UserDaoTest {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(new Class[]{DaoFactory.class});
        UserDao dao = (UserDao)context.getBean("userDao", UserDao.class);
    }
}
```

애플리케이션 컨텍스트는 `ApplicationContext` 타입의 오브젝트다. `ApplicationContext`를 구현한 클래스는 여러 가지가 있는데 `DacFactory`처럼 **@Configuration**이 붙은 자바 코드를 설정정보로 사용하려면 
`AnnotationConfigApplicationContext` 를 이용하면 된다. 애플리케이션 컨텍스트를 만들 때 생성자 파라미터로 `DaoFactory` 클래스를 넣어주고 `ApplicationContext`의 `getBean()` 메서드를 이용해 `UserDao`의 오브젝트를 가져올 수 있다.

`getBean()` 메서드는 `ApplicationContext`가 관리하는 오브젝트를 요청하는 메서드다. `getBean()`의 파라미터인 “userDao”는 `ApplicationContext`에 등록된 빈의 이름이다. `DaoFactory`에서 @Bean이라는 애노테이션을 `userDao`라는 이름의 메서드에 붙였는데, 이 **메서드 이름이 빈의 이름이 된다**.

### 애플리케이션 컨텍스트의 동작방식

기존에 오브젝트 팩토리를 이용했던 방식 vs 스프링의 애플리케이션 컨텍스트를 사용한 방식

오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트다.

스프링에서는 **애플리케이션 컨텍스트**를 **IoC 컨테이너**라 하기도 하고, **스프링 컨테이너** 또는 **빈 팩토리**라고 한다.

애플리케이션 컨텍스트는 ApplicationContext 인터페이스를 구현하는데, ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈 팩토리인 셈이다.

`DaoFactory`가 `UserDao`를 비롯한 DAO 오브젝트를 생성하고 DB 생성 오브젝트와 관계를 맺어주는 제한적인 역할을 하는 데 반해, **애플리케이션 컨텍스트**는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다. 대신 `ApplicationContext`에는 `DaoFactory`와 달리 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 그런 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻는다. 때로는 외부의 오브젝트 팩토리에 그 작업을 위임하고 그 결과를 가져다가 사용하기도 한다.

@Configuration이 붙은 `DaoFactory`는 애플리케이션 컨텍스트가 활용하는 IoC 설정정보다. 내부적으로는 애플리케이션 컨텍스트가 `DaoFactory`의 `userDao()` 메서드를 호출해서 오브젝트를 가져온 것을 클라이언트가 `getBean()`으로 요청할 때 전달해준다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/7906535b-8bd9-4b46-bb34-32a1e3e81a43/image.png)

1. **애플리케이션 컨텍스트**는 `DaoFactory` 클래스(@Configuration)를 설정정보로 등록해두고 @Bean이 붙은 메서드의 이름을 가져와 빈 목록을 만들어둔다.
2. 클라이언트가 애플리케이션 컨텍스트의 `getBean()` 을 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾고, 있다면 빈을 생성하는 메서드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다.

### DaoFactory를 오브젝트 팩토리로 사용했을 때와 비교해서 애플리케이션 컨텍스트를 사용했을 때의 장점

- **클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다**
    - 애플리케이션의 규모가 커질수록 오브젝트도 추가될 것이다. 필요할 때마다 팩토리 오브젝트를 생성하는 번거로움이 있지만 애플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 아무리 많아져도 이를 알아야 하거나 직접 사용할 필요가 없다. 또한 일관된 방식으로 원하는 오브젝트를 가져올 수 있고, 자바 코드 대신 XML처럼 단순한 방법을 사용해 설정정보를 만들 수 있다.
- **애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다**
    - 애플리케이션 컨텍스트는 오브젝트 생성과 다른 오브젝트와의 관계설정뿐만 아니라 오브젝트가 만들어지는 방식,시점과 전략을 다르게 가져갈 수도 있고, 이에 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다. 또 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해주기도 한다.
- **애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다**
    - 애플리케이션 컨텍스트의 `getBean()` 메서드는 빈의 이름을 이용해 빈을 찾아주지만, 타입만으로 빈을 검색하거나 특별한 애노테이션 설정이 되어 있는 빈을 찾을 수도 있다.

### 스프링 IoC의 용어 정리

> **빈(bean)**
빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이며 관리되는 오브젝트(managed object)라고 부르기도 한다.
주의할 점은 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 점이다.
그 중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 한다.

**빈 팩토리(bean factory)**
스프링의 IoC를 담당하는 핵심 컨테이너
빈을 등록하고 생성하고 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당한다.
보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다.
BeanFactory라고 붙여쓰면 빈 팩토리가 구현하고 있는 가장 기본적인 인터페이스의 이름이 된다.

**애플리케이션 컨텍스트(application context)**
빈 팩토리를 확장한 IoC 컨테이너다.
빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일하다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.
빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고, 애플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것이라고 보면 된다. 스프링에서는 애플리케이션 컨텍스트를 빈 팩토리보다 더 많이 사용한다. ApplicationContext라고 적으면 애플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스를 가리키는 것이다.
ApplicationContext는 BeanFactory를 상속한다.

**설정정보/설정 메타정보(configuration metadata)**
스프링의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
실제로 스프링의 설정정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만, 그보다는 IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.
애플리케이션의 형상 정보라고 부르기도 한다.

**컨테이너 또는 IoC 컨테이너(container)**
IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다.
후자는 주로 빈 팩토리의 관점에서 이야기하는 것이고, 그냥 컨테이너 또는 스프링 컨테이너라고 할 때는 애플리케이션 컨텍스트를 가리키는 것이라고 보면 된다.
컨테이너라는 말 자체가 IoC의 개념을 담고 있기 때문에 이름이 긴 애플리케이션 컨텍스트 대신에 스프링 컨테이너라고 부르는 걸 선호하기도 한다.
또 컨테이너라는 말은 애플리케이션 컨텍스트보다 추상적인 표현이기도 하다.
애플리케이션 컨텍스트는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데, 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용된다. 이를 통틀어 **스프링 컨테이너**라고 부를 수 있다.

**스프링 프레임워크(spring framework)**
IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용한다.
그냥 스프링이라고 줄여서 말하기도 한다.
> 

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

> **오브젝트의 동일성과 동등성**

자바에서 두 개의 오브젝트가 같은가라는 말은 주의해서 써야 한다. 자바에서는 두 개의 오브젝트가 완전히 같은 동일한(identical) 오브젝트라고 말하는 것과 동일한 정보를 담고 있는(equivalent) 오브젝트라고 말하는 것은 분명한 차이가 있다. 전자는 동일성(identify) 비교이고, 후자는 동등성(equality) 비교이다. 동일성은 `==` 연산자로, 동등성은 `equals()` 메서드로 비교한다.

두 개의 오브젝트가 동일한다면 사실은 하나의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다. 두 개의 오브젝트가 동일하지는 않지만 동등한 경우에는 두 개의 각기 다른 오브젝트가 메모리상에 존재하는 것인데, 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다. 물론 동일한 오브젝트는 동등하기도 할 것이다. 하지만 그 반대는 항상 참은 아니다.

자바 클래스를 만들 때 `equals()` 메서드를 따로 구현하지 않았다면, 최상위 클래스인 `Object` 클래스에 구현되어 있는 `equals()` 메서드가 사용된다. `Object`의 `equals()` 메서드는 두 오브젝트의 동일성을 비교해서 그 결과를 돌려준다. 따라서 이 때는 동일한 오브젝트여야지만 동등한 오브젝트라고 여겨질 것이다.
> 

**애플리케이션 컨텍스트**는 **IoC 컨테이너**이면서 동시에 싱글톤을 저장하고 관리하는 **싱글톤 레지스트리(singleton registry)**이기도 하다.

스프링은 기본적으로 별다른 설정을 하지 않으면  내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. 여기서 싱글톤은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 구현 방법은 확연히 다르다.

### 서버 애플리케이션과 싱글톤

왜 스프링은 싱글톤으로 빈을 만들까?

그것은 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다.

클라이언트로부터 매번 초당 수십에서 수백 개의 요청이 들어올 때, 요청 때마다 새로운 오브젝트를 생성한다면 부하가 걸려 서버가 감당하기 힘들다.

그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔고, 서블릿은 서비스 오브젝트의 가장 기본이 되는 기술이다.

스펙에서 강제하진 않지만, 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다.

서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

이렇게 애플리케이션 안에 제한된 수, 대개 **한 개의 오브젝트만 만들어서 사용**하는 것이 **싱글톤 패턴**의 원리다.

따라서 서버환경에서는 싱글톤의 사용이 권장된다. 디자인 패턴에 소개된 싱글톤 패턴은 사용하기가 까다롭고 여러 가지 문제점이 있다. 그래서 안티패턴으로도 불린다.

> **싱글톤 패턴(Singleton Pattern)**
GoF가 소개한 디자인 패턴 중의 하나다. 디자인 패턴 중에서 가장 자주 활용되는 패턴이기도 하지만 가장 많은 비판을 받는 패턴이기도 하다.
심지어 디자인 패턴 책을 쓴 GoF 멤버조차도 싱글톤 패턴은 매우 조심해서 사용해야 하거나 피해야 할 패턴이라고 말한다.

싱글톤 패턴은 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다.
이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 전역에서 접근이 가능하다.
단일 오브젝트만 존재해야 하고, 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다.
> 

### 싱글톤 패턴의 한계

일반적으로 자바에서 싱글톤을 구현하는 방법

- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private으로 만든다.
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 정적(static) 필드를 정의한다.
- 정적 팩토리 메서드인 `getInstance()` 를 만들고 이 메서드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 정적 필드에 저장되거나 정적 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
- 한번 오브젝트(싱글톤)가 만들어지고 난 후에는 `getInstance()` 를 통해 이미 만들어져 정적 필드에 저장해둔 오브젝트를 넘겨준다.

하지만 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.

**private 생성자를 갖고 있기 때문에 상속할 수 없다.**

싱글톤 패턴은 생성자를 private으로 제한한다. 문제는 private 생성자 외에 다른 생성자가 없다면 상속이 불가능하다는 점이다.

객체지향의 장점인 상속과 다형성을 적용할 수 없다. 또한 상속과 다형성같은 객체지향의 특징이 적용되지 않는 정적 멤버(필드, 메서드)를 사용하는 것도 동일한 문제를 발생시킨다.

**싱글톤은 테스트하기가 힘들다**

싱글톤은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다.

싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트할 때 mock 등으로 대체하기가 힘들다. 싱글톤은 초기화 과정에서 생성자 등을 통해 사용할 오브젝트를 동적으로 주입하기도 힘들기 때문에 필요한 오브젝트는 직접 오브젝트를 만들어 사용할 수밖에 없다. 이런 경우 테스트용 오브젝트로 대체하기가 힘들다. 테스트는 엔터프라이즈 개발의 핵심인데 애플리케이션 코드를 싱글톤으로 만들면 테스트를 만드는 데 지장이 있다는 건 큰 단점이다.

**서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다**

서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.

따라서 자바 언어를 이용한 싱글톤 패턴 기법은 서버환경에서는 싱글톤이 꼭 보장된다고 볼 수 없다.

여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.

**싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다**

싱글톤은 사용하는 클라이언트가 정해져 있지 않다.

싱글톤의 정적 메서드를 이용해 언제든지 전역으로 싱글톤에 쉽게 접근할 수 있다.

아무 객체나 자유롭게 접근하고 수정할 수 있는 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는다.

그럴 바에는 정적 필드와 정적 메서드로만 구성된 클래스를 사용하는 편이 낫다.

### 싱글톤 레지스트리

자바의 기본적인 싱글톤 패턴 구현 방식은 여러 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 **싱글톤 레지스트리(singleton registry)**를 제공한다.

스프링 컨테이너는 싱글톤을 생성하고, 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다.

싱글톤 레지스트리의 장점은 **정적 멤버를 사용하지 않는 평범한 자바 클래스를 싱글톤으로 활용**하게 해준다는 점이다.

평범한 자바 클래스라도 IoC 방식의 컨테이너를 사용해서 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다.

**오브젝트 생성에 관한 모든 권한은 IoC 기능을 제공하는 애플리케이션 컨텍스트에게 있기 때문이다.**

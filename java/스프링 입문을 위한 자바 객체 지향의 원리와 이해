참고

[https://expert0226.tistory.com/category/강좌/Spring 3.0](https://expert0226.tistory.com/category/%EA%B0%95%EC%A2%8C/Spring%203.0)

https://github.com/expert0226/oopinspring

한국 스프링 사용자 모임

https://groups.google.com/g/ksug

## Chap 01. 사람을 사랑한 기술

### **CBD(컴포넌트 기반 개발, Component Based Development)**

애플리케이션을 통짜로 개발하지 말고, 애플리케이션을 의미 있는 단위로 구분하고 그 단위를 하나 하나씩 부품으로 개발해 마치 레고 블록을 쌓아 올리듯 부품을 결합해 소프트웨어 제품을 완성하자는 개발방법론

### SOA(서비스 지향 구조, Service Oriented Architecture)

개발자 입장에서의 개발이 아니라 실제 현실의 업무를 기준으로 개발하자는 사상

---

## Chap 02. 자바와 절차적/구조적 프로그래밍

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/68981447-730c-4b3d-94f8-fb44e644d6f6/image.png)

하나의 프로그램이 실행될 때 프로그램이 메모리를 사용하는 방식은 **코드 실행 영역**과 **데이터 저장 영역**으로 나뉘며, 기계어를 포함한 모든 프로그래밍 언어의 공통된 메모리 사용 방식이다. 객체 지향 프로그램에서는 데이터 저장 영역을 다시 세 개의 영역으로 분할해서 사용한다.

### main() 메서드: 메서드 스택 프레임

```java
public class Start {
	public static void main(String[] args) {
    	System.out.println("Hello OOP!");
    }
}
```

main() 메서드는 프로그램이 실행되는 시작점이다.

main() 메서드가 실행될 때 메모리, 특히 T 메모리에는 어떤 일이 일어나는지 확인해본다.

![T 메모리 구조](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/9a4cfb51-4811-4279-9b9f-e40f5cd778d1/image.png)

T 메모리 구조

1. JRE는 먼저 프로그램 안에 main() 메서드가 있는지 확인한다.
    - JRE는 Start 클래스에서 main() 메서드를 발견할 수 있을 것이다. main() 메서드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비에 착수한다. 가상의 기계인 **JVM에 전원을 넣어 부팅**하는 것이다.
    - 부팅된 JVM은 목적 파일을 받아 그 목적 파일을 실행한다.

1. JVM은 가장 먼저 **전처리** 과정을 거친다.
    - 모든 자바 프로그램이 반드시 포함되게 하는 **java.lang 패키지**를 T 메모리의 `static 영역`에 가져다 놓는다.
    - java.lang 패키지가 있어 System.out.println() 같은 메서드를 사용할 수 있다.

![main() 메서드 실행 준비 1단계 - java.lang 패키지 배치](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/ba78d31b-7195-42b6-9087-d818652c902e/image.png)

main() 메서드 실행 준비 1단계 - java.lang 패키지 배치

1. JVM은 개발자가 작성한 모든 클래스와 import 패키지 모두 `static 영역`에 가져다 놓는다.
    - 그래서 `static 영역`을 “클래스들의 놀이터”라고 한다.

![main() 메서드 실행 준비 2단계 - 클래스와 import 패키지 배치](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/ae23f13d-9540-4e8b-8997-a24e08ac98d2/image.png)

main() 메서드 실행 준비 2단계 - 클래스와 import 패키지 배치

**main() 메서드가 실행되기 전 JVM에서 수행하는 전처리 작업들**

- java.lang 패키지를 T 메모리의 `static 영역`에 배치한다.
- import된 패키지를 T 메모리의 `static 영역`에 배치한다.
- 프로그램 상의 모든 클래스를 T 메모리의 `static 영역`에 배치한다.

1. main() 메서드 스택 프레임(stack frame)이 `stack 영역`에 할당된다.
    - 클래스 정의하는 여는 중괄호 `{`를 제외하고 여는 중괄호 `{` 를 만날 때마다 스택 프레임이 하나씩 생긴다.

![main() 메서드 스택 프레임](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/a3a0ab94-fec4-408c-adc6-f1798ca06831/image.png)

main() 메서드 스택 프레임

1. main 메서드의 인자 args를 저장할 변수 공간을 스택 프레임의 맨 밑에 확보한다.
    - 메서드 인자(들)의 변수 공간을 할당하는 것이다.
    - 이렇게 T 메모리를 구성한 후에야 main() 메서드 안의 첫 명령문을 실행한다.
    
    ![ main() 메서드 스택 프레임과 인자 변수 공간](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/5c0f0b93-842a-475e-a427-fef3c915310b/image.png)
    
     main() 메서드 스택 프레임과 인자 변수 공간
    

### 멀티 스레드 / 멀티 프로세스의 이해

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/cdd78b91-e400-4412-a6a7-ec6e716ce2d1/image.png)

- 멀티 스레드(Multi Thread)의 T 메모리 모델은 `stack 영역`을 스레드 개수만큼 분할해서 사용한다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/34deb4e5-9bc1-480e-aa07-9574b7b1d8fd/image.png)

- 멀티 프로세스(Multi Process)는 다수의 데이터 저장 영역, 즉 다수의 T 메모리를 갖는 구조다.

---

## Chap 03. 자바와 객체 지향

세상에 존재하는 모든 것은 사물, 즉 객체(Object)이다.

**그리하여 우리가 주변에서 사물을 인지하는 방식대로 프로그래밍할 수 있지 않을까?**

하는 것이 객체 지향의 출발이다.

0과 1로 대변되는 기계(컴퓨터)에 맞춰 사고하던 방식을 버리고 현실세계를 인지하는 방식으로 프로그램을 만들자는 것이다. 그래서 **객체지향은 직관적이다.**

### 객체지향의 4대 특성

- 캡슐화(Encapsulation): 정보 은닉(Information Hiding)
- 상속(~~Inheritance~~): 재사용
- 추상화(Abstraction): 모델링
- 다형성(Polymorphism): 사용 편의

객체: 유일무이(unique)한 사물

클래스: 같은 특성을 지닌 여러 개체를 총칭하는 집합의 개념

- 반, 학급, 모임과 같은 뜻으로 가장 많이 사용되며, **객체들을 특성에 따라 분류**했다는 뜻이다.

**Example**

- 사람 홍길동 = new 사람();
- 사람 줄리엣 = new 사람();

클래스를 이용해 객체(object)를 만들었다는 것을 강조할 때는 객체라는 표현보다는 **클래스의 인스턴스(instance)**라는 표현을 사용한다.

객체(object) = 클래스의 인스턴스

**사람이라는 클래스를 설계**

사람 클래스를 만들기 위해 주변에서 보이는 실체들, 즉 사람 객체들을 관찰해서 사람 객체들이 가진 공통된 특성을 찾게된다.

- 속성 : 시력, 몸무게, 혈액형, 키, 나이, 직업, 취미 등 명사로 표현되는 특성
- 메서드(기능/행위) : 먹다, 자다, 일하다, 운전하다, 울다 등 동사로 표현되는 특성을 기능/행위라고 하며, 객체 지향에서는 **메서드**라고 한다.

**애플리케이션 경계**(컨텍스트, Context)

내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가?

**추상화**

구체적인 것을 분해해서 관심 영역(애플리케이션 경계, Application Boundary)에 있는 특성만 가지고 재조합하는 것 = **모델링**

모델은 실제 사물을 정확히 복제하는 게 아니라 **목적에 맞게 관심있는 특성만을 추출해서 표현**하는 것이다. 바로 모델은 추상화를 통해 실제 사물을 단순하게 묘사하는 것이다.

![애플리케이션 경계에 따른 사람 클래스의 설계 차이](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/c87fc858-b386-4f59-b59f-705ef9151693/image.png)

애플리케이션 경계에 따른 사람 클래스의 설계 차이

- OOP의 추상화는 모델링이다.
- 클래스 : 객체 = 펭귄 : 뽀로로
- 클래스 설계에서 추상화가 사용된다.
- 클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다.
- 객체 지향에서 추상화의 결과는 클래스다.

**추상화 = 모델링 = 자바의 class 키워드**

### 추상화와 T 메모리

클래스 멤버 = static 멤버 = 정적 멤버

객체 멤버 = 인스턴스 멤버

### 상속: 재사용 + 확장

객체 지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속(특성 상속)하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미다.

상속 관계에서 반드시 만족해야 할 문장이 있다.

- 하위 클래스는 상위 클래스다.
    - 포유류는 동물이다.
    - 고래는 포유류다.
    - 고래는 동물이다.

상속은 is a 관계를 만족해야 한다는 말이 있다.

하지만 is a 보다는 is a kind of 가 더 명확한 표현이다.

- 하위 클래스 is a kind of 상위 클래스 → 하위 클래스는 상위 클래스의 한 분류다
- 고래 is a kind of 동물 → 고래는 동물의 한 분류다.

💡 정리

- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

### 다중 상속과 자바

자바는 다중 상속을 지원하지 않고 다중 상속을 간접적으로 구현할 수 있는 인터페이스를 만들었다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/0a08179c-6898-4f98-8b89-2a2ddd15c8b3/27f4ccf0-cca9-4d82-a578-181cfd901678/image.png)

인터페이스는 be able to, 즉 “무엇을 할 수 있는”이라는 표현 형태로 만드는 것이 좋다. 자바 API에서도 이러한 be able to 형식의 인터페이스를 많이 볼 수 있다.

- Serializable 인터페이스 : 직렬화할 수 있는
- Cloneable 인터페이스 : 복제할 수 있는
- Comparable 인터페이스 : 비교할 수 있는
- Runnable 인터페이스 : 실행할 수 있는

하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다.

### 다형성: 사용편의성

오버라이딩

오버로딩

- 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한 메서드가 호출된다.
    - 인스턴스 타입에 따라 다름
    - Animal animal = new Dog(); → Dog에서 오버라이딩한 메서드가 호출됨
    - Animal animal = new Animal(); → Animal의 메서드가 호출됨

### 캡슐화: 정보 은닉

### 참조 변수의 복사

---

## Chap 04. 자바가 확장한 개체 지향

추상 메서드(Abstract Method)

선언부는 있는데 구현부가 없는 메서드

추상 메서드를 하나라도 갖고 있는 클래스는 반드시 추상 클래스로 선언해야 한다.
